using UnityEditor;
using UnityEngine;
using System.Collections;

/// <file>
/// 
/// <author>
/// Adam Mechtley
/// http://adammechtley.com/donations
/// </author>
/// 
/// <copyright>
/// Copyright (c) 2011,  Adam Mechtley.
/// All rights reserved.
/// 
/// Redistribution and use in source and binary forms, with or without
/// modification, are permitted provided that the following conditions are met:
/// 
/// 1. Redistributions of source code must retain the above copyright notice,
/// this list of conditions and the following disclaimer.
/// 
/// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
/// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
/// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
/// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
/// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
/// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
/// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
/// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
/// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
/// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
/// POSSIBILITY OF SUCH DAMAGE.
/// </copyright>
/// 
/// <summary>
/// This file contains an AssetPostprocessor that searches an incoming file for
/// user properties indicating that it contains data for BlendShapes (linear
/// per-vertex deformation). It will automatically set up the BlendShape
/// components on the incoming models, removing extraneous data.
/// 
/// Put this script in an Editor folder and it will automatically operate on
/// incoming files. Files must have correctly-formatted user properties.
/// 
/// This script expects each model to have BlendShapes stored in specific
/// "sidecar" models in the file, indicated by appropriate user properties.
/// THESE SIDECAR MODELS ARE NOT SIMPLY DUPLICATES OF THE TARGETS IN THE SOURCE
/// FILE. The FBX importer will not reliably maintain point count or order on
/// different models that have congruent indices and winding orders in the
/// modeling application, as the importer optimizes the models for stripping.
/// 
/// The first sidecar model, marked with isBlendShapeMapFor, is a duplicate of
/// the base mesh with vertex colors applied. Because two identical models come
/// into Unity with identical point order and topology, this model serves as an
/// index map to the original points in the modeling application. The index for
/// each point is encoded in the red and green color channels for the vertex
/// color values (bits 0-7 in red, 8-15 in green).
/// 
/// The second sidecar model, marked with isSeamlessBaseMeshFor, points to the
/// first sidecar model, and is a dummy mesh with the exact point count and
/// order as that in the modeling application. This is achieved using a
/// duplicate of the base mesh with a single subMesh and no uv coordinates.
/// 
/// The third kind of sidecar model, marked with isBlendShapeTargetFor, points
/// to the first sidecar model. There will be one of these models for each
/// target in the modeling application. These are also color-coded in order to
/// identify corresponding indices on the second sidecar model to generate
/// delta position values for the targets.
/// 
/// The sidecar models can be automatically generated by invoking
/// amTools.unity.blendShapes.exportBlendShapes() from FBXMayaExport.mel if
/// using Maya. If you're using Max, then your problems are manifold. See
/// adammechtley.com for more information on the amTools Python package.
/// </summary>
/// 
/// </file>

/// <summary>
/// Import blend shape data that have been stored in the file
/// </summary>
public class ImportBlendShapeData : AssetPostprocessor
{
	/// <summary>
	/// key is tagged base mesh GameObject, value is name of actual base mesh
	/// </summary>
	private Hashtable baseShapePairs = new Hashtable();
	/// <summary>
	/// key is name of tagged base mesh GameObject, value is corresponding seamless base mesh GameObject
	/// </summary>
	private Hashtable seamlessShapePairs = new Hashtable();
	/// <summary>
	/// key is name of tagged base mesh, value is ArrayList of GameObjects with meshes that are targets for the base mesh
	/// </summary>
	private Hashtable targetMeshes = new Hashtable();
	
	/// <summary>
	/// the minimum sqrMag for a delta value to be stored in a target
	/// </summary>
	public float sqrMagThreshold = 0.00001f;
	
	/// <summary>
	/// static accessor for other Maya AssetPostprocessors
	/// </summary>
	public static int postProcessOrder { get { return -100; } }
	
	/// <summary>
	/// Ensure this script executes before others by default
	/// </summary>
	/// <returns>
	/// A <see cref="System.Int32"/>
	/// </returns>
	public override int GetPostprocessOrder ()
	{
		return postProcessOrder;
	}
	
	/// <summary>
	/// Locate the meshes serving as index maps/data containers
	/// </summary>
	/// <param name="go">
	/// A <see cref="GameObject"/>
	/// </param>
	/// <param name="propNames">
	/// A <see cref="System.String[]"/>
	/// </param>
	/// <param name="values">
	/// A <see cref="System.Object[]"/>
	/// </param>
	void OnPostprocessGameObjectWithUserProperties(GameObject go, string[] propNames, System.Object[] values)
	{
		for (int i=0; i<propNames.Length; i++)
		{
			// link this tagged base mesh to its corresponding actual base mesh
			if (propNames[i] == "isBlendShapeMapFor")
			{
				baseShapePairs.Add(go, values[i] as string);
			}
			
			// link this seamless base mesh to its corresponding actual base mesh
			if (propNames[i] == "isSeamlessBaseMeshFor")
			{
				seamlessShapePairs.Add(values[i] as string, go);
			}
			
			// store the models for each target
			if (propNames[i] == "isBlendShapeTargetFor")
			{
				ArrayList targetModels;
				if (!targetMeshes.Contains(values[i] as string))
				{
					targetModels = new ArrayList();
					targetModels.Add(go);
					targetMeshes.Add(values[i] as string, targetModels);
				}
				else
				{
					targetModels = targetMeshes[values[i] as string] as ArrayList;
					targetModels.Add(go);
					targetMeshes[values[i] as string] = targetModels;
				}
			}
		}
	}
	
	/// <summary>
	/// Decode the tag index stored in the color value
	/// </summary>
	/// <param name="col">
	/// A <see cref="Color"/>
	/// </param>
	/// <returns>
	/// A <see cref="System.Int32"/>
	/// </returns>
	int ColorToTag(Color col)
	{	
		// first convert each color value to an integer
		int rInt = (int)(col.r*255.0);
		int gInt = (int)(col.g*255.0);
		// next, composite the first 8 bits of each component into a single 16-bit representation
		byte[] tagBytes = new byte[2] {System.BitConverter.GetBytes(rInt)[0], System.BitConverter.GetBytes(gInt)[0]};
		return System.BitConverter.ToInt16(tagBytes, 0);
	}
	
	/// <summary>
	/// Hook up the BlendShape data
	/// </summary>
	/// <param name="go">
	/// A <see cref="GameObject"/>
	/// </param>
	public virtual void OnPostprocessModel(GameObject go)
	{
		// early out if no blend shape data were found
		if (baseShapePairs.Count < 1) return;
		
		// process each blend shape data object
		foreach (GameObject indexMap in baseShapePairs.Keys)
		{
			// grab the container for the new BlendShape component from the HashTable
			Transform blendContainer = TransformHelpers.GetTransformInHierarchy(go.transform, baseShapePairs[indexMap] as string);
			// if no match is found, try to find a skin with the mesh
			Component[] skins = go.GetComponentsInChildren<SkinnedMeshRenderer>();
			foreach (SkinnedMeshRenderer skin in skins)
			{
				if (skin.sharedMesh.name == baseShapePairs[indexMap] as string)
					blendContainer = skin.transform;
			}
			// if no match was found, then assume it is the root
			if (blendContainer == null || blendContainer.renderer == null)
			{
				blendContainer = go.transform;
			}
			// add the blendShape component if it does not yet exist
			BlendShape blendShapeNode = blendContainer.gameObject.AddComponent<BlendShape>();
			blendShapeNode.meshRenderer = blendShapeNode.renderer;
			
			// grab the base mesh to map target indices and the ArrayList of target models
			Mesh taggedBaseMesh = indexMap.GetComponent<MeshFilter>().sharedMesh;
			ArrayList targetModels = targetMeshes[indexMap.name] as ArrayList;
			
			// grab the seamless base mesh
			GameObject seamlessBaseModel = seamlessShapePairs[indexMap.name] as GameObject;
			blendShapeNode.seamlessBaseMesh = seamlessBaseModel.GetComponent<MeshFilter>().sharedMesh;
			
			// create the index map between the seamless base mesh and the actual base mesh
			Mesh outMesh;
			if (blendShapeNode.GetComponent<MeshFilter>() == null)
				outMesh = blendShapeNode.GetComponent<SkinnedMeshRenderer>().sharedMesh;
			else
				outMesh = blendShapeNode.GetComponent<MeshFilter>().sharedMesh;
			blendShapeNode.indexMap = new int[outMesh.vertexCount];
			for (int i=0; i<taggedBaseMesh.colors.Length; i++)
			{
				// point indices on the seamless mesh should be identical to tag values
				blendShapeNode.indexMap[i] = ColorToTag(taggedBaseMesh.colors[i]);
			}
			
			// create BlendShapeTargets from the target models
			blendShapeNode.targets = new BlendShape.Target[targetModels.Count];
			for (int i=0; i<targetModels.Count; i++)
			{
				// create the new BlendShapeTarget
				GameObject targetModel = targetModels[i] as GameObject;
				Mesh targetMesh = targetModel.GetComponent<MeshFilter>().sharedMesh;
				BlendShape.Target target = new BlendShape.Target();
				target.name = targetMesh.name.Substring(targetMesh.name.LastIndexOf("__blendShapeTarget__")+20);
				
				// store the indices and deltaPosition values for the target
				ArrayList vertices = new ArrayList();
				ArrayList deltaPos = new ArrayList();
				for (int j=0; j<targetMesh.vertexCount; j++)
				{
					int tag = ColorToTag(targetMesh.colors[j]);
					Vector3 compareTo = blendShapeNode.seamlessBaseMesh.vertices[tag]; // simply use tag since it should be identical to point index on seamless mesh
					// early out if the threshold test is not satisfied
					if ((targetMesh.vertices[j]-compareTo).sqrMagnitude < sqrMagThreshold) continue;
					vertices.Add(tag);
					deltaPos.Add(targetMesh.vertices[j]-compareTo);
				}
				target.vertices = new int[vertices.Count];
				for (int j=0; j<target.vertices.Length; j++)
					target.vertices[j] = (int)vertices[j];
				target.deltaPositions = new Vector3[deltaPos.Count];
				for (int j=0; j<target.deltaPositions.Length; j++)
					target.deltaPositions[j] = (Vector3)deltaPos[j];
				
				// copy the target to the BlendShape component
				blendShapeNode.targets[i] = target;
				
				// remove the target's assets
				GameObject.DestroyImmediate(targetMesh, true);
				GameObject.DestroyImmediate(targetModel, true);
			}
			
			// remove the tagged base mesh assets
			GameObject.DestroyImmediate(taggedBaseMesh, true);
			GameObject.DestroyImmediate(indexMap, true);
			// remove the seamless base mesh GameObject
			GameObject.DestroyImmediate(seamlessBaseModel, true);
		}
	}
}